(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{453:function(t,e,s){"use strict";s.r(e);var a=s(33),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vuex-遇到的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-遇到的问题"}},[t._v("#")]),t._v(" vuex 遇到的问题")]),t._v(" "),s("h2",{attrs:{id:"getter-解构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getter-解构"}},[t._v("#")]),t._v(" getter 解构")]),t._v(" "),s("ul",[s("li",[t._v("mapGetters 放到 methods 中的原因：\n"),s("ul",[s("li",[t._v("oem.type不会发生变化，仅仅是调用一个接口然后赋值，这里主要是 computed 与 methods 的区别，使用 computed 主要是响应式数据的改变引发重新渲染，而这里不需要做这样的事情，无需把它认为是 store 的计算属性。")])])])]),t._v(" "),s("h2",{attrs:{id:"多模块间传递-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多模块间传递-state"}},[t._v("#")]),t._v(" 多模块间传递 state")]),t._v(" "),s("ul",[s("li",[t._v("项目 vuex 没有使用命名空间，getters 是全局的，放到了一起，适用于比较少的场景。\n"),s("ul",[s("li",[t._v("在 actions 中使用跨模块的 state ，其中 context 参数中包含了 rootState 的全局状态，可以利用 rootstate.moduleName.xxx 来调用。类似的还有 rootGetters ，但是因为是全局注册的 getters，所以可以直接使用 getters 在各个模块中。")])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);